import {renderComponent, unrenderComponent} from "../utils";
import CardBoard from "../components/card-board";
import Day from "../components/day-container";
import Sort from "../components/sort";
import PointController from "./point-controller";

class TripController {
  /**
   * @param {Element} container
   * @param { [{duration: {hours: (string|number), minutes: (string|number), days: (string|number)},
   *            startTime: number,
   *            endTime: number}] } waypoints
   * @param { [ {
   *   tripDay: number,
   *   day: number,
   *   month: string,
   *   dayCode: number
   *        } ] } tripDaysData
   */
  constructor(container, waypoints, tripDaysData) {
    this._container = container;
    this._waypoints = waypoints;
    this._tripDaysData = tripDaysData;
    this._eventContainerIndex = 0;
    this._board = new CardBoard();
    this._sort = new Sort();
    this._dayElement = new Day(tripDaysData).getElement();
    this._onDataChange = this._onDataChange.bind(this);
  }

  init() {
    renderComponent(this._container, this._sort.getElement(), `beforeend`);
    renderComponent(this._container, this._board.getElement(), `beforeend`);
    renderComponent(this._board.getElement().firstElementChild, this._dayElement, `beforeend`);

    this._waypoints.forEach((it, dayIndex) => {
      if ((dayIndex > 0) && (this._tripDaysData[dayIndex].tripDay !== this._tripDaysData[dayIndex - 1].tripDay)) {
        this._eventContainerIndex++;
      }

      this._renderTripWaypoint(it, this._eventContainerIndex);
    });

    this._sort.getElement().querySelector(`.trip-sort`).addEventListener(`click`, (evt) => this._onSortElementClick(evt));
  }

  /**
   * @param {{duration: {hours: (string|number), minutes: (string|number), days: (string|number)},
   *            startTime: number,
   *            endTime: number}} tripWaypoint
   * @param {number} containerIndex
   * @private
   */
  _renderTripWaypoint(tripWaypoint, containerIndex) {
    const pointController = new PointController(this._dayElement.querySelectorAll(`.trip-events__list`)[containerIndex], tripWaypoint, this._onDataChange);
  }

  _onDataChange(newData, oldData) {
    console.log(newData);
    this._waypoints[this._waypoints.findIndex((it) => it === oldData)] = newData;
    console.log(this._waypoints);
    // document.querySelectorAll(`.trip-events__list`)[0].children
    // unrenderComponent(document.querySelector(`.trip-days`));
    // document.querySelector(`.trip-days`).innerHTML = ``;
    // renderComponent(this._board.getElement().firstElementChild, this._dayElement, `beforeend`);
    unrenderComponent(this._board.getElement());
    this._board = new CardBoard();
    renderComponent(this._container, this._board.getElement(), `beforeend`);
    // this._board.getElement().querySelector(`.trip-days`).innerHTML = ``;
    this._dayElement = new Day(this._tripDaysData).getElement();
    renderComponent(this._board.getElement().firstElementChild, this._dayElement, `beforeend`); // ?
    this._eventContainerIndex = 0;
    this._waypoints.forEach((it, dayIndex) => {
      if ((dayIndex > 0) && (this._tripDaysData[dayIndex].tripDay !== this._tripDaysData[dayIndex - 1].tripDay)) {
        this._eventContainerIndex++;
      }

      this._renderTripWaypoint(it, this._eventContainerIndex);
    });

    /*this._waypoints.forEach((it, dayIndex) => {
      if ((dayIndex > 0) && (this._tripDaysData[dayIndex].tripDay !== this._tripDaysData[dayIndex - 1].tripDay)) {
        this._eventContainerIndex++;
      }

      this._renderTripWaypoint(it, this._eventContainerIndex);
    });*/
  }

  /**
   * @param {Event} evt
   * @private
   */
  _onSortElementClick(evt) {
    const clearDaysData = () => {
      document.querySelectorAll(`.day__counter`).forEach((it) => {
        unrenderComponent(it);
        // it.innerHTML = ``;
      });
      document.querySelectorAll(`.day__date`).forEach((it) => {
        unrenderComponent(it);
        // it.innerHTML = ``;
      });
    };

    if (evt.target.tagName !== `INPUT`) {
      return;
    }
    this._board.getElement().firstElementChild.innerHTML = ``;
    // this._board = new CardBoard();
    this._dayElement = new Day(this._tripDaysData).getElement();
    this._eventContainerIndex = 0;
    console.log(this._container);
    renderComponent(this._container, this._board.getElement(), `beforeend`);
    renderComponent(this._board.getElement().firstElementChild, this._dayElement, `beforeend`);

    switch (evt.target.dataset.sortType) {
      case `event`:
        this._waypoints.forEach((it, index) => {
          this._renderTripWaypoint(it, index);
        });
        break;

      case `time`:
        this._waypoints.slice()
          .sort((a, b) => (parseInt(a.time.duration.days, 10) - parseInt(b.time.duration.days, 10)) || (parseInt(a.time.duration.hours, 10) - parseInt(b.time.duration.hours, 10)) || (parseInt(a.time.duration.minutes, 10) - parseInt(b.time.duration.minutes, 10)))
          .forEach((it, index) => {
            this._renderTripWaypoint(it, index);
          });
        clearDaysData();
        break;

      case `price`:
        this._waypoints.slice().sort((a, b) => a.waypointPrice - b.waypointPrice).forEach((it, index) => {
          this._renderTripWaypoint(it, index);
        });
        clearDaysData();
        break;
    }
  }
}

export default TripController;


1.1
Наименование маршрута путешествия формируется автоматически и состоит из пунктов назначения (названий городов), разделённых тире: «Amsterdam — Geneva — Chamonix». Если городов больше 3-х, то в наименовании маршрута отображается первый и последний город, разделённые многоточием: «Amsterdam — … — Chamonix».
Даты путешествия в шапке заполняются автоматически. Дата начала всего путешествия соответствует дате начала первой точки маршрута. Дата окончания — дате завершения последней точки маршрута. Например, «18 AUG — 6 OCT»
Общая стоимость путешествия пересчитывается при создании/изменении/удалении любой точки маршрута.
Новая точка маршрута создаётся нажатием на кнопку «New Event». После нажатия пользователь видит форму создания новой точки маршрута, где ему необходимо заполнить несколько полей.
1.2
Путешествие строится из отдельных точек маршрута. Точка маршрута — отдельное событие в путешествии. Точкой маршрута может быть остановка в каком-нибудь месте (Check, Sightseeing, Restaurant) или поездка на транспортном средстве (Taxi, Bus, Train, Ship, Transport, Drive и Flight).
Точка маршрута принадлежит к одному из типов: Taxi, Bus, Train, Ship, Transport, Drive, Flight, Check, Sightseeing, Restaurant.
Точки маршрута загружаются с сервера при старте приложения. На время загрузки вместо маршрута нужно вывести сообщение «Loading…».
В случае отсутствия точек маршрута вместо списка отображается текст: «Click New Event to create your first point».
1.3
По умолчанию точка маршрута в списке отображается в режиме просмотра.
В колонке «Time» отображается время и продолжительность нахождения в точке маршрута (разность между окончанием и началом события). Время маршрута отображается в формате «Начало» — «Окончание» (10:30 — 11:00). Формат продолжительности нахождения в точки маршрута зависит от длительности:
Менее часа: 00M (23M);
Менее суток: 00H 00M (02H 44M);
Более суток: 00D 00H 00M (01D 02H 30M);
В колонке «Offers» отображаются не более 3-х дополнительных опций, применённых к точке маршрута. Остальные опции пользователь может посмотреть открыв карточку точки маршрута.
1.4
Новая точка маршрута создаётся нажатием на кнопку «New Event». Форма создания новой точки маршрута появляется в самом начале списка.
Нажатие на кнопку «New Event» закрывает открытую форму редактирования точки маршрута, если таковая была. Изменения при закрытии не сохраняются.
В форме создания новой точки маршрута пользователю доступны следующие элементы управления:
Кнопка «Save». Сохранение точки маршрута и закрытие формы создания точки маршрута.
Кнопка «Cancel». Отмена создания новой точки маршрута. Закрытие формы создания точки маршрута.
Для создания новой точки маршрута пользователь заполняет:
Тип точки маршрута (один из: Taxi, Bus, Train, Ship, Transport, Drive, Flight, Check, Sightseeng, Restaurant.).
Пункт назначения. Выбирается из списка предложенных значений, полученных с сервера. Пользователь не может ввести свой вариант для пункта назначения.
Дата и время начала события. Выбор времени и даты осуществляется с помощью компонента flatpickr.js. Выбранная дата и время отображаются в поле в формате: DD.MM.YYYY HH:mm. Например: 12.12.2019 16:00.
Дата и время окончания события. Выбор времени и даты осуществляется с помощью компонента flatpickr.js. Выбранная дата и время отображаются в поле в формате: DD.MM.YYYY HH:mm. Например: 31.12.2019 16:20. Дата окончания не может быть меньше даты начала события.
Стоимость. Целое число.
Дополнительные опции. В зависимости от типа точки маршрута пользователь может выбрать дополнительные опции.
Информация о дополнительных опциях загружается с сервера.
Дополнительные опции отображаются после выбора (изменении) типа точки маршрута.
Пользователь может отметить одну или несколько дополнительных опций.
Дополнительная опция применяется к точке маршрута один раз. Повторный клик на дополнительную опцию отменяет ее применение.
Список дополнительных опций доступен не для всех типов точек маршрута. Для некоторых типов точек дополнительные опции могут отсутствовать. В этом случае контейнер для вывода дополнительных опций не отображается.
Выбор дополнительных опций влияет на общую стоимость путешествия. Стоимость точки маршрута при этом не изменяется.
При изменении типа точки маршрута выбранный ранее список оферов очищается.
При выборе типа точки маршрута должен обновляться вспомогательный текст (плейсхолдер). Текст плейсхолдера зависит от типа точки:
Для точек регистрирующих перемещение пользователя на транспортном средстве (Flight, Taxi и т. д.): « to»: flight to, taxi to, bus to и т. д.
Для точек регистрирующих прибытие в определенное место (Sightseeing, Restaurant, Check-In): « in». Например: sightseeing in, check-in in и т. д.
После выбора пункта назначения появляется блок «Destination». В нём отображается информация о месте назначения (изображения, текст). Информация для блока «Destination» загружается с сервера.
Если информация о пункте назначения отсутствует блок «Destination» не отображается. Информация в блоке «Destination» всегда соответствует выбранному пункту назначения. При изменении пункта назначения информация в блоке «Destination» обновляется.
После сохранения точка маршрута располагается в списке точек маршрута в порядке определенном текущей сортировкой (по умолчанию, по длительности или по стоимости).
1.5
Для перехода к форме редактирования точки маршрута пользователь кликает по кнопке с изображением «Стрелка вниз» в правом углу карточки точки маршрута.
В форме редактирования пользователю доступны следующие элементы управления:
Кнопка «Save». Сохраняет изменения, закрывает форму редактирования.
Кнопка «Delete». Удаляет точку маршрута, закрывает форму редактирования.
Кнопка «Favorite» (отображается в виде звёздочки). Добавляет точку маршрута в избранное. После добавления в избранное, кнопка меняет состояние — закрашенная звезда. Повторный клик по кнопке удаляет точку маршрута из избранного и возвращает кнопку в исходное состояние.
В форме редактирования представлены все поля, которые пользователь заполняет при создании новой точки маршрута (см. раздел «Новая точка маршрута»). Правила их поведения сохраняются.
При нажатии кнопки «Esc» форма редактирования закрывается. Несохранённые изменения пропадают.
Одновременно может быть открыта только одна форма редактирования для одной точки маршрута.
Если пользователь внёс изменения в точку маршрута, не выполнил сохранение и пытается перейти к редактированию другой точки маршрута, то в этом случае первая форма редактирования закрывается без сохранения изменений. Открывается форма редактирования для второй точки маршрута.
После сохранения точка маршрута располагается в списке точек маршрута в порядке определенном текущей сортировкой (по умолчанию, по длительности или по стоимости).
1.6
В приложении предусмотрено несколько фильтров:
Everything — полный список точек маршрута;
Future — список запланированных точек маршрута, т. е. точек у которых дата начала события больше, чем текущая;
Past — список пройденных точек маршрута, т. е. точек у которых дата прибытия в точку маршрута меньше, чем текущая;
Выбор любого из фильтров приводит к отрисовке только тех точек маршрута, которые соответствуют выбранному фильтру;
1.7
Пользователю доступна возможность сортировки точек маршрута по стоимости (клик по заголовку колонки «Price») и длительности (клик по заголовку колонки «Time»). Сортировка работает в одном направлении — от максимального к минимальному: при сортировке по стоимости в начале списка окажутся самые дорогие точки маршрута, при сортировке по длительности — самые долгие.
Для отмены сортировки и возвращению к исходному порядку (разбивка по дням) пользователь кликает по заголовку колонки «Events».
1.8
Статистика «Stats» позволяет пользователю проанализировать расходы и время, затраченное на путешествие. Для удобства просмотра и анализа эта информация представлена в виде нескольких диаграмм: «Money» (финансовые расходы), «Transport» (транспортные расходы) и «Time-spend» (затраченное время в разрезе точек маршрута).
Для просмотра статистики пользователь нажимает на кнопку «Stats».
Диаграмма «Money» показывает финансовые затраты в разрезе точек маршрута. Она позволяет ответить на вопрос: «Сколько за время путешествия было потрачено на такси или рестораны?». Диаграмма «Money» не учитывает дополнительные опции, только стоимость точек маршрута.
Диаграмма «Transport» показывает статистику по транспортным средствам, которыми придется воспользоваться в путешествии. Диаграмма отвечает на вопрос: «Сколько раз нам придется воспользоваться самолётом, такси и т. д.».
Диаграмма: «Time-Spend» показывает сколько времени было затрачено на отдельные точки маршрута. Диаграмма позволяет ответить на вопрос: «Сколько дней пользователь проведёт в отеле».
1.9
Сервер расположен по адресу https://htmlacademy-es-9.appspot.com/big-trip/.
Каждый запрос к серверу должен содержать заголовок Authorization со значением Basic ${случайная строка}. Например, Basic er883jdzbdw. Случайная строка формируется однократно при старте приложения.
1.10
При нажатии на кнопки «Save», «Delete», «Favorite» формируется запрос к серверу на добавление/изменение/удаление информации. На время выполнения запроса текст заголовка кнопки изменяется:
«Save» -> «Saving…»
«Delete» -> «Deleting…»
Заголовки кнопок возвращаются в исходный вид после выполнения запроса.
Перед отправкой запроса на создание/удаление/изменение информации по точке маршрута форма блокируется от внесения изменений. Разблокировка формы происходит после завершения выполнения запроса (неважно, успешно выполнен запрос или нет).
Обновление элементов (удаление точки маршрута, обновление точки маршрута и т.д) в DOM происходит после успешного выполнения запроса к серверу.
Если запрос не удалось выполнить (сервер недоступен, произошла ошибка), форма редактирования/создания остается открытой, к ней применяется эффект «покачивание головой».
